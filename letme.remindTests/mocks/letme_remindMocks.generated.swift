//
//  letme_remindMocks.generated.swift
//  letme_remind
//
//  Generated by Mockingbird v0.20.0.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import letme_remind
import Combine
import Foundation
import NotificationCenter
import Swift
import SwiftUI
import Swinject
import UserNotifications
import os

private let mkbGenericStaticMockContext = Mockingbird.GenericStaticMockContext()

// MARK: - Mocked LocalNotificationPermissionsProvider
public final class LocalNotificationPermissionsProviderMock: letme_remind.LocalNotificationPermissionsProvider, Mockingbird.Mock {
  typealias MockingbirdSupertype = letme_remind.LocalNotificationPermissionsProvider
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "letme_remind"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    LocalNotificationPermissionsProviderMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `isLocalNotificationPermissionsGranted`()
  public func `isLocalNotificationPermissionsGranted`() async -> Bool {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`isLocalNotificationPermissionsGranted`() async -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Bool).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () async -> Bool { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Bool = await mkbObject.`isLocalNotificationPermissionsGranted`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Bool).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `isLocalNotificationPermissionsGranted`() async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> Bool, Bool> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> Bool, Bool>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`isLocalNotificationPermissionsGranted`() async -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Bool).self)))
  }
}

/// Returns a concrete mock of `LocalNotificationPermissionsProvider`.
public func mock(_ type: letme_remind.LocalNotificationPermissionsProvider.Protocol, file: StaticString = #file, line: UInt = #line) -> LocalNotificationPermissionsProviderMock {
  return LocalNotificationPermissionsProviderMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked LocalNotificationProvider
public final class LocalNotificationProviderMock: letme_remind.LocalNotificationProvider, Mockingbird.Mock {
  typealias MockingbirdSupertype = letme_remind.LocalNotificationProvider
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "letme_remind"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    LocalNotificationProviderMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `pendingNotifications`()
  public func `pendingNotifications`() async -> [UNNotificationRequest] {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`pendingNotifications`() async -> [UNNotificationRequest]", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier(([UNNotificationRequest]).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () async -> [UNNotificationRequest] { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: [UNNotificationRequest] = await mkbObject.`pendingNotifications`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: ([UNNotificationRequest]).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `pendingNotifications`() async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> [UNNotificationRequest], [UNNotificationRequest]> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> [UNNotificationRequest], [UNNotificationRequest]>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`pendingNotifications`() async -> [UNNotificationRequest]", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier(([UNNotificationRequest]).self)))
  }
}

/// Returns a concrete mock of `LocalNotificationProvider`.
public func mock(_ type: letme_remind.LocalNotificationProvider.Protocol, file: StaticString = #file, line: UInt = #line) -> LocalNotificationProviderMock {
  return LocalNotificationProviderMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked LocalNotificationScheduler
public final class LocalNotificationSchedulerMock: letme_remind.LocalNotificationScheduler, Mockingbird.Mock {
  typealias MockingbirdSupertype = letme_remind.LocalNotificationScheduler
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "letme_remind"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    LocalNotificationSchedulerMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `schedule`(`note`: letme_remind.Note, `when`: letme_remind.WhenToRemind)
  public func `schedule`(`note`: letme_remind.Note, `when`: letme_remind.WhenToRemind) async -> Result<Void, letme_remind.ScheduleError> {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`schedule`(`note`: letme_remind.Note, `when`: letme_remind.WhenToRemind) async -> Result<Void, letme_remind.ScheduleError>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`note`), Mockingbird.ArgumentMatcher(`when`)], returnType: Swift.ObjectIdentifier((Result<Void, letme_remind.ScheduleError>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (letme_remind.Note, letme_remind.WhenToRemind) async -> Result<Void, letme_remind.ScheduleError> { return await mkbImpl(`note`, `when`) }
      if let mkbImpl = mkbImpl as? () async -> Result<Void, letme_remind.ScheduleError> { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Result<Void, letme_remind.ScheduleError> = await mkbObject.`schedule`(note: `note`, when: `when`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Result<Void, letme_remind.ScheduleError>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `schedule`(`note`: @autoclosure () -> letme_remind.Note, `when`: @autoclosure () -> letme_remind.WhenToRemind) async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (letme_remind.Note, letme_remind.WhenToRemind) async -> Result<Void, letme_remind.ScheduleError>, Result<Void, letme_remind.ScheduleError>> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (letme_remind.Note, letme_remind.WhenToRemind) async -> Result<Void, letme_remind.ScheduleError>, Result<Void, letme_remind.ScheduleError>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`schedule`(`note`: letme_remind.Note, `when`: letme_remind.WhenToRemind) async -> Result<Void, letme_remind.ScheduleError>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`note`), Mockingbird.resolve(`when`)], returnType: Swift.ObjectIdentifier((Result<Void, letme_remind.ScheduleError>).self)))
  }
}

/// Returns a concrete mock of `LocalNotificationScheduler`.
public func mock(_ type: letme_remind.LocalNotificationScheduler.Protocol, file: StaticString = #file, line: UInt = #line) -> LocalNotificationSchedulerMock {
  return LocalNotificationSchedulerMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked NotesPersistenceBindings
public final class NotesPersistenceBindingsMock: letme_remind.NotesPersistenceBindings, Mockingbird.Mock {
  typealias MockingbirdSupertype = letme_remind.NotesPersistenceBindings
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "letme_remind"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    NotesPersistenceBindingsMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `makeNotesArchivePersistenceBinding`()
  public func `makeNotesArchivePersistenceBinding`() -> Binding<Data> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`makeNotesArchivePersistenceBinding`() -> Binding<Data>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Binding<Data>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Binding<Data> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Binding<Data> = mkbObject.`makeNotesArchivePersistenceBinding`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Binding<Data>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `makeNotesArchivePersistenceBinding`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Binding<Data>, Binding<Data>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Binding<Data>, Binding<Data>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`makeNotesArchivePersistenceBinding`() -> Binding<Data>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Binding<Data>).self)))
  }

  // MARK: Mocked `makeNotesToRemindPersistenceBinding`()
  public func `makeNotesToRemindPersistenceBinding`() -> Binding<Data> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`makeNotesToRemindPersistenceBinding`() -> Binding<Data>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Binding<Data>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Binding<Data> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Binding<Data> = mkbObject.`makeNotesToRemindPersistenceBinding`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Binding<Data>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `makeNotesToRemindPersistenceBinding`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Binding<Data>, Binding<Data>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Binding<Data>, Binding<Data>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`makeNotesToRemindPersistenceBinding`() -> Binding<Data>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Binding<Data>).self)))
  }

  // MARK: Mocked `makeUnhandledNotesPersistenceBinding`()
  public func `makeUnhandledNotesPersistenceBinding`() -> Binding<Data> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`makeUnhandledNotesPersistenceBinding`() -> Binding<Data>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Binding<Data>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Binding<Data> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Binding<Data> = mkbObject.`makeUnhandledNotesPersistenceBinding`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Binding<Data>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `makeUnhandledNotesPersistenceBinding`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Binding<Data>, Binding<Data>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Binding<Data>, Binding<Data>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`makeUnhandledNotesPersistenceBinding`() -> Binding<Data>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Binding<Data>).self)))
  }
}

/// Returns a concrete mock of `NotesPersistenceBindings`.
public func mock(_ type: letme_remind.NotesPersistenceBindings.Protocol, file: StaticString = #file, line: UInt = #line) -> NotesPersistenceBindingsMock {
  return NotesPersistenceBindingsMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked NotesReader
public final class NotesReaderMock: letme_remind.NotesReader, Mockingbird.Mock {
  typealias MockingbirdSupertype = letme_remind.NotesReader
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "letme_remind"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    NotesReaderMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `count`(_ `notes`: Binding<Data>)
  public func `count`(_ `notes`: Binding<Data>) -> Int {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`count`(_ `notes`: Binding<Data>) -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`notes`)], returnType: Swift.ObjectIdentifier((Int).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Binding<Data>) -> Int { return mkbImpl(`notes`) }
      if let mkbImpl = mkbImpl as? () -> Int { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Int = mkbObject.`count`(`notes`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Int).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `count`(_ `notes`: @autoclosure () -> Binding<Data>) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Binding<Data>) -> Int, Int> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Binding<Data>) -> Int, Int>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`count`(_ `notes`: Binding<Data>) -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`notes`)], returnType: Swift.ObjectIdentifier((Int).self)))
  }

  // MARK: Mocked `one`(by `id`: String, from `notesData`: Binding<Data>)
  public func `one`(by `id`: String, from `notesData`: Binding<Data>) -> letme_remind.Note? {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`one`(by `id`: String, from `notesData`: Binding<Data>) -> letme_remind.Note?", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`id`), Mockingbird.ArgumentMatcher(`notesData`)], returnType: Swift.ObjectIdentifier((letme_remind.Note?).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (String, Binding<Data>) -> letme_remind.Note? { return mkbImpl(`id`, `notesData`) }
      if let mkbImpl = mkbImpl as? () -> letme_remind.Note? { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: letme_remind.Note? = mkbObject.`one`(by: `id`, from: `notesData`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (letme_remind.Note?).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `one`(by `id`: @autoclosure () -> String, from `notesData`: @autoclosure () -> Binding<Data>) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String, Binding<Data>) -> letme_remind.Note?, letme_remind.Note?> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String, Binding<Data>) -> letme_remind.Note?, letme_remind.Note?>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`one`(by `id`: String, from `notesData`: Binding<Data>) -> letme_remind.Note?", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`id`), Mockingbird.resolve(`notesData`)], returnType: Swift.ObjectIdentifier((letme_remind.Note?).self)))
  }

  // MARK: Mocked `read`(from `notesData`: Binding<Data>)
  public func `read`(from `notesData`: Binding<Data>) -> letme_remind.Notes {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`read`(from `notesData`: Binding<Data>) -> letme_remind.Notes", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`notesData`)], returnType: Swift.ObjectIdentifier((letme_remind.Notes).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Binding<Data>) -> letme_remind.Notes { return mkbImpl(`notesData`) }
      if let mkbImpl = mkbImpl as? () -> letme_remind.Notes { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: letme_remind.Notes = mkbObject.`read`(from: `notesData`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (letme_remind.Notes).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `read`(from `notesData`: @autoclosure () -> Binding<Data>) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Binding<Data>) -> letme_remind.Notes, letme_remind.Notes> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Binding<Data>) -> letme_remind.Notes, letme_remind.Notes>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`read`(from `notesData`: Binding<Data>) -> letme_remind.Notes", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`notesData`)], returnType: Swift.ObjectIdentifier((letme_remind.Notes).self)))
  }
}

/// Returns a concrete mock of `NotesReader`.
public func mock(_ type: letme_remind.NotesReader.Protocol, file: StaticString = #file, line: UInt = #line) -> NotesReaderMock {
  return NotesReaderMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked NotesWriter
public final class NotesWriterMock: letme_remind.NotesWriter, Mockingbird.Mock {
  typealias MockingbirdSupertype = letme_remind.NotesWriter
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "letme_remind"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    NotesWriterMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `remove`(_ `note`: letme_remind.Note, from `notes`: Binding<Data>)
  public func `remove`(_ `note`: letme_remind.Note, from `notes`: Binding<Data>) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`remove`(_ `note`: letme_remind.Note, from `notes`: Binding<Data>) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`note`), Mockingbird.ArgumentMatcher(`notes`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (letme_remind.Note, Binding<Data>) -> Void { return mkbImpl(`note`, `notes`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`remove`(`note`, from: `notes`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `remove`(_ `note`: @autoclosure () -> letme_remind.Note, from `notes`: @autoclosure () -> Binding<Data>) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (letme_remind.Note, Binding<Data>) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (letme_remind.Note, Binding<Data>) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`remove`(_ `note`: letme_remind.Note, from `notes`: Binding<Data>) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`note`), Mockingbird.resolve(`notes`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `write`(_ `note`: letme_remind.Note, to `notes`: Binding<Data>)
  public func `write`(_ `note`: letme_remind.Note, to `notes`: Binding<Data>) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`write`(_ `note`: letme_remind.Note, to `notes`: Binding<Data>) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`note`), Mockingbird.ArgumentMatcher(`notes`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (letme_remind.Note, Binding<Data>) -> Void { return mkbImpl(`note`, `notes`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`write`(`note`, to: `notes`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `write`(_ `note`: @autoclosure () -> letme_remind.Note, to `notes`: @autoclosure () -> Binding<Data>) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (letme_remind.Note, Binding<Data>) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (letme_remind.Note, Binding<Data>) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`write`(_ `note`: letme_remind.Note, to `notes`: Binding<Data>) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`note`), Mockingbird.resolve(`notes`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns a concrete mock of `NotesWriter`.
public func mock(_ type: letme_remind.NotesWriter.Protocol, file: StaticString = #file, line: UInt = #line) -> NotesWriterMock {
  return NotesWriterMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked NotificationCenterAdapter
public final class NotificationCenterAdapterMock: letme_remind.NotificationCenterAdapter, Mockingbird.Mock {
  typealias MockingbirdSupertype = letme_remind.NotificationCenterAdapter
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "letme_remind"])

  // MARK: Mocked delegate
  public var `delegate`: UNUserNotificationCenterDelegate? {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "delegate.getter", setterSelectorName: "delegate.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((UNUserNotificationCenterDelegate?).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> UNUserNotificationCenterDelegate? { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as UNUserNotificationCenterDelegate? }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: UNUserNotificationCenterDelegate? = mkbObject.`delegate`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (UNUserNotificationCenterDelegate?).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "delegate.setter", setterSelectorName: "delegate.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (UNUserNotificationCenterDelegate?) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`delegate` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getDelegate() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> UNUserNotificationCenterDelegate?, UNUserNotificationCenterDelegate?> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> UNUserNotificationCenterDelegate?, UNUserNotificationCenterDelegate?>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "delegate.getter", setterSelectorName: "delegate.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((UNUserNotificationCenterDelegate?).self)))
  }

  public func setDelegate(_ newValue: @autoclosure () -> UNUserNotificationCenterDelegate?) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (UNUserNotificationCenterDelegate?) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (UNUserNotificationCenterDelegate?) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "delegate.setter", setterSelectorName: "delegate.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    NotificationCenterAdapterMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `requestAuthorization`(`options`: UNAuthorizationOptions)
  public func `requestAuthorization`(`options`: UNAuthorizationOptions) async throws -> Bool {
    return try await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`requestAuthorization`(`options`: UNAuthorizationOptions) async throws -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`options`)], returnType: Swift.ObjectIdentifier((Bool).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (UNAuthorizationOptions) async throws -> Bool { return try await mkbImpl(`options`) }
      if let mkbImpl = mkbImpl as? () async throws -> Bool { return try await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Bool = try await mkbObject.`requestAuthorization`(options: `options`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Bool).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `requestAuthorization`(`options`: @autoclosure () -> UNAuthorizationOptions) async -> Mockingbird.Mockable<Mockingbird.ThrowingAsyncFunctionDeclaration, (UNAuthorizationOptions) async throws -> Bool, Bool> {
    return Mockingbird.Mockable<Mockingbird.ThrowingAsyncFunctionDeclaration, (UNAuthorizationOptions) async throws -> Bool, Bool>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`requestAuthorization`(`options`: UNAuthorizationOptions) async throws -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`options`)], returnType: Swift.ObjectIdentifier((Bool).self)))
  }

  // MARK: Mocked `add`(_ `request`: UNNotificationRequest)
  public func `add`(_ `request`: UNNotificationRequest) async throws -> Void {
    return try await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`add`(_ `request`: UNNotificationRequest) async throws -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`request`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (UNNotificationRequest) async throws -> Void { return try await mkbImpl(`request`) }
      if let mkbImpl = mkbImpl as? () async throws -> Void { return try await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = try await mkbObject.`add`(`request`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `add`(_ `request`: @autoclosure () -> UNNotificationRequest) async -> Mockingbird.Mockable<Mockingbird.ThrowingAsyncFunctionDeclaration, (UNNotificationRequest) async throws -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.ThrowingAsyncFunctionDeclaration, (UNNotificationRequest) async throws -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`add`(_ `request`: UNNotificationRequest) async throws -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`request`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `pendingNotificationRequests`()
  public func `pendingNotificationRequests`() async -> [UNNotificationRequest] {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`pendingNotificationRequests`() async -> [UNNotificationRequest]", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier(([UNNotificationRequest]).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () async -> [UNNotificationRequest] { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: [UNNotificationRequest] = await mkbObject.`pendingNotificationRequests`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: ([UNNotificationRequest]).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `pendingNotificationRequests`() async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> [UNNotificationRequest], [UNNotificationRequest]> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> [UNNotificationRequest], [UNNotificationRequest]>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`pendingNotificationRequests`() async -> [UNNotificationRequest]", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier(([UNNotificationRequest]).self)))
  }

  // MARK: Mocked `notificationSettings`()
  public func `notificationSettings`() async -> letme_remind.NotificationSettingsAdapter {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`notificationSettings`() async -> letme_remind.NotificationSettingsAdapter", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((letme_remind.NotificationSettingsAdapter).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () async -> letme_remind.NotificationSettingsAdapter { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: letme_remind.NotificationSettingsAdapter = await mkbObject.`notificationSettings`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (letme_remind.NotificationSettingsAdapter).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `notificationSettings`() async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> letme_remind.NotificationSettingsAdapter, letme_remind.NotificationSettingsAdapter> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> letme_remind.NotificationSettingsAdapter, letme_remind.NotificationSettingsAdapter>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`notificationSettings`() async -> letme_remind.NotificationSettingsAdapter", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((letme_remind.NotificationSettingsAdapter).self)))
  }
}

/// Returns a concrete mock of `NotificationCenterAdapter`.
public func mock(_ type: letme_remind.NotificationCenterAdapter.Protocol, file: StaticString = #file, line: UInt = #line) -> NotificationCenterAdapterMock {
  return NotificationCenterAdapterMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked NotificationSettingsAdapter
public final class NotificationSettingsAdapterMock: letme_remind.NotificationSettingsAdapter, Mockingbird.Mock {
  typealias MockingbirdSupertype = letme_remind.NotificationSettingsAdapter
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "letme_remind"])

  // MARK: Mocked authorizationStatus
  public var `authorizationStatus`: UNAuthorizationStatus {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "authorizationStatus.getter", setterSelectorName: "authorizationStatus.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((UNAuthorizationStatus).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> UNAuthorizationStatus { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as UNAuthorizationStatus }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: UNAuthorizationStatus = mkbObject.`authorizationStatus`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (UNAuthorizationStatus).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getAuthorizationStatus() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> UNAuthorizationStatus, UNAuthorizationStatus> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> UNAuthorizationStatus, UNAuthorizationStatus>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "authorizationStatus.getter", setterSelectorName: "authorizationStatus.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((UNAuthorizationStatus).self)))
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    NotificationSettingsAdapterMock.mockingbirdContext.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `NotificationSettingsAdapter`.
public func mock(_ type: letme_remind.NotificationSettingsAdapter.Protocol, file: StaticString = #file, line: UInt = #line) -> NotificationSettingsAdapterMock {
  return NotificationSettingsAdapterMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked UserDefaultsAdapter
public final class UserDefaultsAdapterMock: letme_remind.UserDefaultsAdapter, Mockingbird.Mock {
  typealias MockingbirdSupertype = letme_remind.UserDefaultsAdapter
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "letme_remind"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    UserDefaultsAdapterMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `data`(forKey `defaultName`: String)
  public func `data`(forKey `defaultName`: String) -> Data? {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`data`(forKey `defaultName`: String) -> Data?", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`defaultName`)], returnType: Swift.ObjectIdentifier((Data?).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (String) -> Data? { return mkbImpl(`defaultName`) }
      if let mkbImpl = mkbImpl as? () -> Data? { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Data? = mkbObject.`data`(forKey: `defaultName`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Data?).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `data`(forKey `defaultName`: @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> Data?, Data?> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> Data?, Data?>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`data`(forKey `defaultName`: String) -> Data?", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`defaultName`)], returnType: Swift.ObjectIdentifier((Data?).self)))
  }

  // MARK: Mocked `setValue`(_ `value`: Any?, forKey `key`: String)
  public func `setValue`(_ `value`: Any?, forKey `key`: String) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`setValue`(_ `value`: Any?, forKey `key`: String) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`value`), Mockingbird.ArgumentMatcher(`key`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Any?, String) -> Void { return mkbImpl(`value`, `key`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`setValue`(`value`, forKey: `key`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `setValue`(_ `value`: @autoclosure () -> Any?, forKey `key`: @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Any?, String) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Any?, String) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`setValue`(_ `value`: Any?, forKey `key`: String) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`value`), Mockingbird.resolve(`key`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns a concrete mock of `UserDefaultsAdapter`.
public func mock(_ type: letme_remind.UserDefaultsAdapter.Protocol, file: StaticString = #file, line: UInt = #line) -> UserDefaultsAdapterMock {
  return UserDefaultsAdapterMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}
